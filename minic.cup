import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ScannerBuffer;
import java_cup.runtime.XMLElement;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamWriter;
import java.io.*;
import java.util.*;
import javax.xml.transform.*;
import javax.xml.transform.stream.*;  

parser code {:
    public void syntax_error(Symbol cur_token){
	System.err.println("[SYNTAX ERROR] Syntax error at " + cur_token.value);
    }
    public void unrecovered_syntax_error(Symbol cur_token){
	System.err.println("Errore non recuperato coordinate -> " + cur_token.left + " - " + cur_token.right);
    }
    public static void newScope(){
	typenames.push(new HashSet<String>());
    }
    public static void deleteScope(){
	typenames.pop();
    }
    public static boolean lookupType(String name){
	for (HashSet<String> scope: typenames)
	    if (scope.contains(name)) return true;
	return false;
    }
    public static void addType(String name){
	typenames.peek().add(name);
    }
    public static LinkedList<HashSet<String>> typenames = new LinkedList<HashSet<String>>();
    public Parser(Lexer lex, ComplexSymbolFactory sf) {
	super(lex,sf);
    }

    public static void main(String[] args) throws Exception {
      // initialize the symbol factory
      ComplexSymbolFactory csf = new ComplexSymbolFactory();
      // create a buffering scanner wrapper
      ScannerBuffer lexer = new ScannerBuffer(new Lexer(new BufferedReader(new FileReader(args[0])),csf));
      // start parsing
      Parser p = new Parser(lexer,csf);
      XMLElement e = (XMLElement)p.parse().value;

      for (XMLElement el: SyntaxTreeXPath.query(args[2],e)){
      	  System.out.println(el.getTagname());
      }


      TestVisitor t = new TestVisitor();
      SyntaxTreeDFS.dfs(e,t);

      // create XML output file 
      XMLOutputFactory outFactory = XMLOutputFactory.newInstance();
      XMLStreamWriter sw = outFactory.createXMLStreamWriter(new FileOutputStream(args[1]));
      // dump XML output to the file
      XMLElement.dump(lexer,sw,e,"expr","stmt");
      
       // transform the parse tree into an AST and a rendered HTML version
      Transformer transformer = TransformerFactory.newInstance()
	    .newTransformer(new StreamSource(new File("tree.xsl")));
      Source text = new StreamSource(new File(args[1]));
      transformer.transform(text, new StreamResult(new File("output.xml")));
      transformer = TransformerFactory.newInstance()
	    .newTransformer(new StreamSource(new File("tree-view.xsl")));
      text = new StreamSource(new File("output.xml"));
      transformer.transform(text, new StreamResult(new File("ast.html")));
  }
:};

/* TERMINAL */
terminal IF, ELSE, WHILE, CURLYL, CURLYR, PARAL, PARAR, IDENT, INTCONST,
	  ADD_ASSIGN, SUB_ASSIGN, MUL_ASSIGN, SCROPPO_ASSIGN, MOD_ASSIGN,
	  LE_OP, GE_OP, EQ_OP, NE_OP, AND_OP, OR_OP, NOT, ASSIGN, MINUS,
	  PLUS, MUL, DIVIDE, MODULUS, LESS, GREATER, SEMI;


/* NON TERMINAL */
non terminal	program;
non terminal	stmt;
non terminal	simp;
non terminal	control;
non terminal	block;
non terminal	exp;
non terminal	asop;
non terminal	binop;
non terminal	unop;

non terminal 	scroppo;


/* PRECEDENCES */
precedence nonassoc PARAR, PARAL;
precedence right NOT;
precedence left MUL, DIVIDE, MODULUS;
precedence left PLUS, MINUS;
precedence left LESS, LE_OP, GREATER, GE_OP;
precedence left EQ_OP, NE_OP;
precedence left AND_OP;
precedence left OR_OP;
precedence left ASSIGN, ADD_ASSIGN,  SUB_ASSIGN, MUL_ASSIGN, SCROPPO_ASSIGN, MOD_ASSIGN; 

start with program;

/* GRAMMAR */
program		::= CURLYL scroppo:scroppex CURLYR
		;

scroppo		::= scroppo:s stmt:st
		|
		;

stmt		::= simp:s SEMI:sc
		| control:c
		| SEMI:sc
		;

simp		::= IDENT:i asop:a exp:e
		;

control		::= IF PARAL exp:e PARAR ELSE block:b
		| IF PARAL exp:e PARAR 
		| WHILE PARAL exp:e PARAR block:b
		;

block		::= stmt:s
		| CURLYL stmt:s CURLYR
		;

exp		::= PARAL exp:e PARAR
		| INTCONST:c
		| IDENT:id
		| unop:u exp:e
		| exp:exp1 binop:bo exp:exp2
		;

asop		::= ASSIGN
		| ADD_ASSIGN
		| SUB_ASSIGN
		| MUL_ASSIGN
		| SCROPPO_ASSIGN
		| MOD_ASSIGN
		;

binop		::= PLUS
		| MINUS
		| MUL
		| DIVIDE
		| MODULUS
		| LESS
		| LE_OP
		| GREATER
		| GE_OP
		| EQ_OP
		| NE_OP
		| AND_OP
		| OR_OP
		;

unop		::= NOT
		| MINUS
		;











